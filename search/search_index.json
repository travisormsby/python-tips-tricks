{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>If you're anything like us, most of what you know about Python you learned by trial and error. Most geospatial professionals don't have much formal training in computer science or software engineering. And that's fine because we're mostly not computer scientists or sofware engineers. We don't have time to train in a whole new career just to write some automation scripts. But the downside of a purely practical education is that it can be easy to settle for suboptimal solutions because we're not aware of better practices that can improve the performance and readability of our code.</p> <p>This session is designed to highlight some common code patterns that work OK, but for which a better approach exists.</p> <ul> <li>Instead of bracket notation, use more unpacking</li> <li>Instead of conditionals for validation, use try/except</li> <li>Instead of rolling your own solutions, use existing Python capabilities </li> <li>Instead of writing setup and teardown code, use context managers </li> <li>Instead of only writing documentation in separate files, use doc strings and type hints.</li> <li>Instead of always modeling data collections as lists, use more tuples and sets</li> <li>Instead of list comprehensions, use more generators</li> <li>Instead of guessing about inefficiencies, profile your code </li> </ul> <p>This workshop is focused on general patterns that you can use no matter what type of problem you are working on. Because these are general patterns, don't expect to be able to lift the code examples here and use them directly in your code. Do expect to take these strategies and apply them to your code. </p> <p>The code examples and exercises are written using Jupyter Notebooks. If you have a Google account, you can click the Open in Colab button at the top to run the notebooks using Google's Colab environment. Otherwise, you can click the download button for each notebook to download it to your local machine and run in a notebook environment (e.g. loading the notebook into ArcGIS Pro). </p>"},{"location":"Documentation/","title":"Help people understand your code","text":"<p>Even if you use Pythonic idioms, your code probably won't be perfectly understandable by itself. You want other people to be able to work with the code you write.</p> <p>An analyst has a function that calculates the distance from a given point to the origin in three dimensions.</p> In\u00a0[\u00a0]: Copied! <pre>def distance_from_origin(x, y, z):\n    return (x**2 + y**2 + z**2) ** 0.5\n</pre> def distance_from_origin(x, y, z):     return (x**2 + y**2 + z**2) ** 0.5 <p>One option is to say that it is perfectly obvious what this function does from its name and parameters. But your functions are much more obvious to you than they are to other people. \"Other people\" includes future you. You do not want future you mad at current you for not explaining what your code does.</p> <p>A better option is to write down explicity what this function does, what kind of arguments you can pass to it, and what kind of value it will return. For example, you might have a text file, or a web page, or a Word doc. Hopefully not a sticky note on your monitor, but even that's better than nothing. Something like:</p> <pre><code>Calculates the distance from a given point in three dimensions to the origin (0, 0, 0). \n\nArgs: \n    x (float): The x-axis coordinate.\n    y (float): The y-axis coordinate.\n    z (float): The z-axis coordinate.\n\nReturns:\n    float: The distance.\n</code></pre> <p>That works OK, but separating your code from your documentation forces people to look in two places. It also means that the built-in <code>help</code> function is mostly useless for learning about your function.</p> In\u00a0[\u00a0]: Copied! <pre>help(distance_from_origin)\n</pre> help(distance_from_origin) <p>A better way to document your code is to include the information as a docstring. You can use docstrings with modules, function, classes, and methods that you create.</p> In\u00a0[\u00a0]: Copied! <pre>def distance_from_origin_docstring(x, y, z):\n    \"\"\"\n    Calculates the distance from a given point in three dimensions to the origin (0, 0, 0). \n\n    Args: \n        x (float): The x-axis coordinate.\n        y (float): The y-axis coordinate.\n        z (float): The z-axis coordinate.\n\n    Returns:\n        float: The distance.\n    \"\"\"\n\n    return (x**2 + y**2 + z**2) ** 0.5\n</pre> def distance_from_origin_docstring(x, y, z):     \"\"\"     Calculates the distance from a given point in three dimensions to the origin (0, 0, 0).       Args:          x (float): The x-axis coordinate.         y (float): The y-axis coordinate.         z (float): The z-axis coordinate.      Returns:         float: The distance.     \"\"\"      return (x**2 + y**2 + z**2) ** 0.5 <p>By including a docstring, people can use the built-in <code>help</code> function to see the information without having to open the source code file.</p> In\u00a0[\u00a0]: Copied! <pre>help(distance_from_origin_docstring)\n</pre> help(distance_from_origin_docstring) <p>Many IDEs will even show the information when you hover over the function name.</p> <p>An analyst tries using the <code>distance_from_origin_docstring</code> function, but is getting an error</p> In\u00a0[\u00a0]: Copied! <pre>coordinates = [2, 5, 4]\ndistance = distance_from_origin_docstring(*coordinates)\ninfo_string = \"The point is \" + distance + \" meters from the origin\"\nprint(info_string)\n</pre> coordinates = [2, 5, 4] distance = distance_from_origin_docstring(*coordinates) info_string = \"The point is \" + distance + \" meters from the origin\" print(info_string) <p>The error is reasonably informative, and the analyst can use it to fix their code. But the problem only showed up after the analyst ran the code. It would be nice to get that information beforehand. Type hints are a way to pass information to type checkers and IDEs that can help ensure that you're using the correct types, without having to actually run the code.</p> In\u00a0[\u00a0]: Copied! <pre>def distance_from_origin_typehints(x: float, y: float, z: float) -&gt; float:\n    \"\"\"\n    Calculates the distance from a given point in three dimensions to the origin (0, 0, 0). \n\n    Args: \n        x (float): The x-axis coordinate.\n        y (float): The y-axis coordinate.\n        z (float): The z-axis coordinate.\n\n    Returns:\n        float: The distance.\n    \"\"\"\n\n    return (x**2 + y**2 + z**2) ** 0.5\n</pre> def distance_from_origin_typehints(x: float, y: float, z: float) -&gt; float:     \"\"\"     Calculates the distance from a given point in three dimensions to the origin (0, 0, 0).       Args:          x (float): The x-axis coordinate.         y (float): The y-axis coordinate.         z (float): The z-axis coordinate.      Returns:         float: The distance.     \"\"\"      return (x**2 + y**2 + z**2) ** 0.5 <p>If the analyst had used this function, type checkers like Mypy would have flagged the use of the <code>distance</code> name as incorrect usage. Then the analyst could have corrected their code before running it and seeing the error.</p> In\u00a0[\u00a0]: Copied! <pre>coordinates = [2, 5, 4]\ndistance = distance_from_origin_typehints(*coordinates)\ninfo_string = \"The point is \" + distance + \" meters from the origin\"\nprint(info_string)\n</pre> coordinates = [2, 5, 4] distance = distance_from_origin_typehints(*coordinates) info_string = \"The point is \" + distance + \" meters from the origin\" print(info_string) <p>Type hints are well-named. They do not force you to use the right types. They will not cause Python to throw an error if you use the wrong types. They give you a hint that you are not using a value correctly.</p> <p>For example, the <code>distance_from_origin_typehints</code> function still executes without an error when you pass it a <code>complex</code> number as an argument, even though a <code>complex</code> is not a <code>float</code>.</p> In\u00a0[\u00a0]: Copied! <pre>coordinates = [2j, 5, 4]\ndistance = distance_from_origin_typehints(*coordinates)\ninfo_string = f\"The point is {distance} meters from the origin\"\nprint(info_string)\n</pre> coordinates = [2j, 5, 4] distance = distance_from_origin_typehints(*coordinates) info_string = f\"The point is {distance} meters from the origin\" print(info_string) <p>Type hints can be used for more complex types, like if you need to have a particular container type and you also need to specify the type of the values inside the container.</p> <ul> <li><code>Iterable</code> is for containers that you want to use in a <code>for</code> loop.</li> <li><code>Sequence</code> is an <code>Iterable</code> that lets you know the length and access an element by index.</li> <li><code>MutableSequence</code> is a <code>Sequence</code> that you might need to change.</li> <li><code>Mapping</code> is for dictionary-like objects where you want to get values by key.</li> <li><code>MutableMapping</code> is a <code>Mapping</code> that you might need to change.</li> <li>If you know you want a specific type, you can also directly use <code>dict</code>, <code>list</code>, <code>tuple</code>, etc.</li> </ul> <p>The code below refactors the distance function to use a single parameter and calculates the distance in any number of dimensions.</p> In\u00a0[\u00a0]: Copied! <pre>from collections.abc import Iterable\n\ndef n_dimension_distance_from_origin(coords: Iterable[float]) -&gt; float:\n    \"\"\"\n    Calculates the distance from a given n-dimensional point to the origin. \n\n    Args: \n        coords (Iterable[float]): \n            An iterable of coordinate values, one for each dimension.\n\n    Returns:\n        float: The distance.\n    \"\"\"\n\n    sum_of_squares = sum(d ** 2 for d in coords)\n    return sum_of_squares ** 0.5\n\nn_dimension_distance_from_origin((1, 1, 1, 1))\nn_dimension_distance_from_origin([1, 1, 1, 1])\nn_dimension_distance_from_origin((\"1\", \"1\", \"1\", \"1\"))\n</pre> from collections.abc import Iterable  def n_dimension_distance_from_origin(coords: Iterable[float]) -&gt; float:     \"\"\"     Calculates the distance from a given n-dimensional point to the origin.       Args:          coords (Iterable[float]):              An iterable of coordinate values, one for each dimension.      Returns:         float: The distance.     \"\"\"      sum_of_squares = sum(d ** 2 for d in coords)     return sum_of_squares ** 0.5  n_dimension_distance_from_origin((1, 1, 1, 1)) n_dimension_distance_from_origin([1, 1, 1, 1]) n_dimension_distance_from_origin((\"1\", \"1\", \"1\", \"1\"))   <p>The exercises below invite you to practice applying the different strategies outlined above. They follow the order of the concepts presented, but you can attempt them in any order. Start with the ones that seem most applicable to the work you need to do.</p> <p>You can find example answers in the ExerciseAnswers.ipynb notebook.</p> In\u00a0[\u00a0]: Copied! <pre>from itertools import cycle\nfrom typing import NamedTuple\n\nclass Vertex(NamedTuple):\n    x: float\n    y: float\n\n\ndef calculate_area(vertices):\n    subtotals = []\n    vertex_cycle = cycle(vertices)\n    next(vertex_cycle)\n    for vertex in vertices:\n        next_vertex = next(vertex_cycle)\n        subtotal = vertex.x * next_vertex.y - vertex.y * next_vertex.x\n        subtotals.append(subtotal)\n    area = abs(sum(subtotals) / 2)\n    return area\n\nvertices = (Vertex(4, 10), Vertex(9, 7), Vertex(11, 2), Vertex(2, 2))\ncalculate_area(vertices)\n</pre> from itertools import cycle from typing import NamedTuple  class Vertex(NamedTuple):     x: float     y: float   def calculate_area(vertices):     subtotals = []     vertex_cycle = cycle(vertices)     next(vertex_cycle)     for vertex in vertices:         next_vertex = next(vertex_cycle)         subtotal = vertex.x * next_vertex.y - vertex.y * next_vertex.x         subtotals.append(subtotal)     area = abs(sum(subtotals) / 2)     return area  vertices = (Vertex(4, 10), Vertex(9, 7), Vertex(11, 2), Vertex(2, 2)) calculate_area(vertices)"},{"location":"Documentation/#help-other-people-understand-your-code","title":"Help other people understand your code\u00b6","text":""},{"location":"Documentation/#docstrings","title":"Docstrings\u00b6","text":""},{"location":"Documentation/#type-hints","title":"Type hints\u00b6","text":""},{"location":"Documentation/#exercises","title":"Exercises\u00b6","text":""},{"location":"Documentation/#1-use-type-hints","title":"1) Use type hints\u00b6","text":"<p>Determine the input and output types of the <code>calculate_area</code> function below, then add type hints.</p> <p>Hint: The correct type for <code>vertices</code> is complex. It is passed to the <code>cycle</code> function, which means you need to be able to loop over it.  The containers inside <code>vertices</code> must have both an <code>x</code> and a <code>y</code> property, and you need to be able to do arithmetic using the values of those properties.</p>"},{"location":"Documentation/#2-add-a-docstring-to-a-function","title":"2) Add a docstring to a function\u00b6","text":"<p>Determine what the <code>calculate area</code> function does, then add a docstring.</p> <p>The examples above use Google-style docstrings, which is a common standard. You may also want to look at other common formats.</p> <p>Hint: It is not actually necessary to understand the shoelace algorithm implemented by this function. You can still write an excellent doc string explaining what it does and how to use it.</p>"},{"location":"ExerciseAnswers/","title":"Exercise Answers","text":"<p>The code cells below are example answers to the workshop exercises. They are useful if you get stuck and need a hint or if you want to use them as a comparison with your own attempts</p> In\u00a0[\u00a0]: Copied! <pre>counties = [\"Anoka\", \"Dakota\", \"Carver\", \"Hennepin\", \"Ramsey\", \"Scott\", \"Washington\"]\nprint(*counties, sep='\\n')\n</pre> counties = [\"Anoka\", \"Dakota\", \"Carver\", \"Hennepin\", \"Ramsey\", \"Scott\", \"Washington\"] print(*counties, sep='\\n') <pre>Anoka\nDakota\nCarver\nHennepin\nRamsey\nScott\nWashington\n</pre> In\u00a0[\u00a0]: Copied! <pre>from dataclasses import dataclass\n\n@dataclass\nclass Record:\n    total_population: int\n    population_in_poverty: int\n\nrecord = Record(5000, 200)\nrecord.total_population = 6000\nprint(record)\n</pre> from dataclasses import dataclass  @dataclass class Record:     total_population: int     population_in_poverty: int  record = Record(5000, 200) record.total_population = 6000 print(record) <pre>Record(total_population=6000, population_in_poverty=200)\n</pre> In\u00a0[\u00a0]: Copied! <pre>from random import randint\n\nnums = [randint(-1000, 1000) for i in range(20)]\n\nprint(max(nums), min(nums))\n</pre> from random import randint  nums = [randint(-1000, 1000) for i in range(20)]  print(max(nums), min(nums)) <pre>891 -899\n</pre> In\u00a0[\u00a0]: Copied! <pre>from typing import NamedTuple\n\nclass Record(NamedTuple):\n    total_population: int\n    population_in_poverty: int\n\nrecord1 = Record(5000, 2000)\nrecord2 = Record(200, 10)\nrecord3 = Record(\"400\", \"30\")\n\ndef poverty_rate(record):\n    total_pop, pop_in_poverty = record\n    return int(pop_in_poverty) / int(total_pop)\n\nfor record in (record1, record2, record3):\n    print(poverty_rate(record))\n</pre> from typing import NamedTuple  class Record(NamedTuple):     total_population: int     population_in_poverty: int  record1 = Record(5000, 2000) record2 = Record(200, 10) record3 = Record(\"400\", \"30\")  def poverty_rate(record):     total_pop, pop_in_poverty = record     return int(pop_in_poverty) / int(total_pop)  for record in (record1, record2, record3):     print(poverty_rate(record)) <pre>0.4\n0.05\n0.075\n</pre> In\u00a0[3]: Copied! <pre>with open(\"data.csv\", \"w\") as f:\n    f.write(\"Important data\")\n    raise ValueError\n</pre> with open(\"data.csv\", \"w\") as f:     f.write(\"Important data\")     raise ValueError <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[3], line 3\n      1 with open(\"data.csv\", \"w\") as f:\n      2     f.write(\"Important data\")\n----&gt; 3     raise ValueError\n\nValueError: </pre> In\u00a0[\u00a0]: Copied! <pre>from itertools import cycle\nfrom collections.abc import Iterable\nfrom typing import NamedTuple\n\nclass Vertex(NamedTuple):\n    x: float\n    y: float\n\ndef calculate_area(vertices: Iterable[Vertex]) -&gt; float:\n    subtotals = []\n    vertex_cycle = cycle(vertices)\n    next(vertex_cycle)\n    for vertex in vertices:\n        next_vertex = next(vertex_cycle)\n        subtotal = vertex.x * next_vertex.y - vertex.y * next_vertex.x\n        subtotals.append(subtotal)\n    area = abs(sum(subtotals) / 2)\n    return area\n\nvertices = (Vertex(4, 10), Vertex(9, 7), Vertex(11, 2), Vertex(2, 2))\ncalculate_area(vertices)\n</pre> from itertools import cycle from collections.abc import Iterable from typing import NamedTuple  class Vertex(NamedTuple):     x: float     y: float  def calculate_area(vertices: Iterable[Vertex]) -&gt; float:     subtotals = []     vertex_cycle = cycle(vertices)     next(vertex_cycle)     for vertex in vertices:         next_vertex = next(vertex_cycle)         subtotal = vertex.x * next_vertex.y - vertex.y * next_vertex.x         subtotals.append(subtotal)     area = abs(sum(subtotals) / 2)     return area  vertices = (Vertex(4, 10), Vertex(9, 7), Vertex(11, 2), Vertex(2, 2)) calculate_area(vertices)  In\u00a0[\u00a0]: Copied! <pre>def calculate_area(vertices: Iterable[Vertex]) -&gt; float:\n    \"\"\"\n    Calculate the area of a polygon given the coordinates of its vertices\n\n    Args:\n        vertices (Iterable[Vertex]): \n            An iterable, such as a list or tuple, of Vertex objects\n            holding the (x, y) coordinates of each vertex\n    Returns:\n        float: The area of the polygon\n    \"\"\"\n    subtotals = []\n    vertex_cycle = cycle(vertices)\n    next(vertex_cycle)\n    for vertex in vertices:\n        next_vertex = next(vertex_cycle)\n        subtotal = vertex.x * next_vertex.y - vertex.y * next_vertex.x\n        subtotals.append(subtotal)\n    area = abs(sum(subtotals) / 2)\n    return area\n\nvertices = (Vertex(4, 10), Vertex(9, 7), Vertex(11, 2), Vertex(2, 2))\ncalculate_area(vertices)\n</pre> def calculate_area(vertices: Iterable[Vertex]) -&gt; float:     \"\"\"     Calculate the area of a polygon given the coordinates of its vertices      Args:         vertices (Iterable[Vertex]):              An iterable, such as a list or tuple, of Vertex objects             holding the (x, y) coordinates of each vertex     Returns:         float: The area of the polygon     \"\"\"     subtotals = []     vertex_cycle = cycle(vertices)     next(vertex_cycle)     for vertex in vertices:         next_vertex = next(vertex_cycle)         subtotal = vertex.x * next_vertex.y - vertex.y * next_vertex.x         subtotals.append(subtotal)     area = abs(sum(subtotals) / 2)     return area  vertices = (Vertex(4, 10), Vertex(9, 7), Vertex(11, 2), Vertex(2, 2)) calculate_area(vertices) Out[\u00a0]: <pre>45.5</pre> In\u00a0[\u00a0]: Copied! <pre>import sys\n\ndef tuple_from_range(start, end):\n  \"\"\"Create a tuple from a range of values\"\"\"\n  return tuple(range(start, end + 1))\n\nstart = 1900\nend = 2030\n\nstudyYears = tuple_from_range(start, end)\n\nprint(studyYears)\nprint(\"Bytes used: \", sys.getsizeof(studyYears))\n</pre> import sys  def tuple_from_range(start, end):   \"\"\"Create a tuple from a range of values\"\"\"   return tuple(range(start, end + 1))  start = 1900 end = 2030  studyYears = tuple_from_range(start, end)  print(studyYears) print(\"Bytes used: \", sys.getsizeof(studyYears)) <pre>(1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030)\nBytes used:  1088\n</pre> In\u00a0[\u00a0]: Copied! <pre>placeNames_list = [\"Kinshasa\", \"Duluth\", \"Uruguay\"] * 1_000_000\nplaceNames_set = set(placeNames_list)\n\n# O(1) set look-up\nif \"Dinkytown\" not in placeNames_set:\n    print(\"Missing.\")  \n</pre> placeNames_list = [\"Kinshasa\", \"Duluth\", \"Uruguay\"] * 1_000_000 placeNames_set = set(placeNames_list)  # O(1) set look-up if \"Dinkytown\" not in placeNames_set:     print(\"Missing.\")   In\u00a0[1]: Copied! <pre>from itertools import cycle\nfrom random import randint\n\nclass Random_Vertex:\n    def __init__(self):\n        self.x = randint(0, 100)\n        self.y = randint(0, 100)\n    \ndef generate_polygon_vertices(num_polygons, num_sides):\n    for _ in range(num_polygons):\n        vertices = (Random_Vertex() for _ in range(num_sides))\n        yield vertices\n\ndef calculate_area(vertices):\n    subtotals = []\n    vertex_cycle = cycle(vertices)\n    next(vertex_cycle)\n    for vertex in vertices:\n        next_vertex = next(vertex_cycle)\n        subtotal = vertex.x * next_vertex.y - vertex.y * next_vertex.x\n        subtotals.append(subtotal)\n    area = abs(sum(subtotals) / 2)\n    return area\n</pre> from itertools import cycle from random import randint  class Random_Vertex:     def __init__(self):         self.x = randint(0, 100)         self.y = randint(0, 100)      def generate_polygon_vertices(num_polygons, num_sides):     for _ in range(num_polygons):         vertices = (Random_Vertex() for _ in range(num_sides))         yield vertices  def calculate_area(vertices):     subtotals = []     vertex_cycle = cycle(vertices)     next(vertex_cycle)     for vertex in vertices:         next_vertex = next(vertex_cycle)         subtotal = vertex.x * next_vertex.y - vertex.y * next_vertex.x         subtotals.append(subtotal)     area = abs(sum(subtotals) / 2)     return area <p>Easier: Use a generator expression to find the triangle with the maximum area instead of a list comprehension</p> In\u00a0[5]: Copied! <pre>triangles = generate_polygon_vertices(1_000_000, 3)\nmax([calculate_area(triangle) for triangle in triangles])\n</pre> triangles = generate_polygon_vertices(1_000_000, 3) max([calculate_area(triangle) for triangle in triangles]) Out[5]: <pre>5000.0</pre> <p>Harder: Write a generator to replace the list comprehension instead of using a generator expression.</p> In\u00a0[6]: Copied! <pre>def calculate_areas(polygons):\n    for polygon in polygons:\n        yield(calculate_area(polygon))\n        \ntriangles = generate_polygon_vertices(1_000_000, 3)\nmax(calculate_areas(triangles))\n</pre> def calculate_areas(polygons):     for polygon in polygons:         yield(calculate_area(polygon))          triangles = generate_polygon_vertices(1_000_000, 3) max(calculate_areas(triangles))  Out[6]: <pre>5000.0</pre> In\u00a0[2]: Copied! <pre>import tracemalloc\n\ntracemalloc.start()\n\ntriangles = generate_polygon_vertices(1_000_000, 3)\nmax([calculate_area(triangle) for triangle in triangles])\n\ncurrent, peak = tracemalloc.get_traced_memory()\nprint(peak)\n</pre> import tracemalloc  tracemalloc.start()  triangles = generate_polygon_vertices(1_000_000, 3) max([calculate_area(triangle) for triangle in triangles])  current, peak = tracemalloc.get_traced_memory() print(peak) <pre>32452069\n</pre> In\u00a0[2]: Copied! <pre>import tracemalloc\n\ntracemalloc.start()\n\ntriangles = generate_polygon_vertices(1_000_000, 3)\nmax(calculate_area(triangle) for triangle in triangles)\n\ncurrent, peak = tracemalloc.get_traced_memory()\nprint(peak)\n</pre> import tracemalloc  tracemalloc.start()  triangles = generate_polygon_vertices(1_000_000, 3) max(calculate_area(triangle) for triangle in triangles)  current, peak = tracemalloc.get_traced_memory() print(peak) <pre>31073\n</pre> In\u00a0[8]: Copied! <pre>%%timeit\ntriangles = generate_polygon_vertices(1_000, 3)\nmax([calculate_area(triangle) for triangle in triangles])\n</pre> %%timeit triangles = generate_polygon_vertices(1_000, 3) max([calculate_area(triangle) for triangle in triangles]) <pre>7.55 ms \u00b1 40.6 \u03bcs per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n</pre> In\u00a0[9]: Copied! <pre>%%timeit \ntriangles = generate_polygon_vertices(1_000, 3)\nmax(calculate_area(triangle) for triangle in triangles)\n</pre>  %%timeit  triangles = generate_polygon_vertices(1_000, 3) max(calculate_area(triangle) for triangle in triangles) <pre>7.54 ms \u00b1 32.5 \u03bcs per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n</pre>"},{"location":"ExerciseAnswers/#exercise-answers","title":"Exercise Answers\u00b6","text":""},{"location":"ExerciseAnswers/#11-use-unpacking-for-pretty-printing","title":"1.1) Use unpacking for pretty printing\u00b6","text":""},{"location":"ExerciseAnswers/#12-use-standard-library-data-classes","title":"1.2) Use standard library data classes\u00b6","text":""},{"location":"ExerciseAnswers/#13-use-the-built-in-min-and-max-functions","title":"1.3) Use the built-in min and max functions\u00b6","text":""},{"location":"ExerciseAnswers/#14-just-do-things","title":"1.4) Just do things\u00b6","text":""},{"location":"ExerciseAnswers/#15-use-pythonic-patterns-for-setup-and-teardown-boilerplate","title":"1.5) Use Pythonic patterns for setup and teardown boilerplate\u00b6","text":""},{"location":"ExerciseAnswers/#21-use-type-hints","title":"2.1) Use type hints\u00b6","text":""},{"location":"ExerciseAnswers/#22-add-a-docstring-to-a-function","title":"2.2) Add a docstring to a function\u00b6","text":""},{"location":"ExerciseAnswers/#31-use-the-right-data-structure-for-immutable-sequences","title":"3.1) Use the right data structure for immutable sequences\u00b6","text":""},{"location":"ExerciseAnswers/#32-use-the-right-data-structure-for-membership-lookup","title":"3.2) Use the right data structure for membership lookup\u00b6","text":""},{"location":"ExerciseAnswers/#33-use-generators","title":"3.3) Use generators\u00b6","text":""},{"location":"ExerciseAnswers/#34-compare-memory-use-of-lists-vs-generators","title":"3.4) Compare memory use of lists vs. generators\u00b6","text":""},{"location":"ExerciseAnswers/#35-check-execution-speed-of-lists-vs-generators","title":"3.5) Check execution speed of lists vs. generators\u00b6","text":""},{"location":"PerformanceMemory/","title":"Optimize performance and memory use","text":"<p>When you begin to use Python regularly in your work, you'll start noticing bottlenecks in your code. Some workflows may run at lightning speed, while others take hours of processing time to complete, or even crash.</p> <p>Avoiding bloat is invaluable as you move toward using code for automation, bigger data, and working with APIs. Code efficiency means:</p> <ul> <li>Less chance of a slowdown or crash: the dreaded MemoryError.</li> <li>Quicker response time and fewer bottlenecks for the larger workflow.</li> <li>Better scaling.</li> <li>Efficient code is often (but not always!) cleaner and more readable.</li> </ul> <p>Let's look at some ways you can reduce bloat in your code.</p> <p>Access and store only what you need, no more.</p> <ul> <li>Storage: avoid a list where you could use a tuple</li> <li>Membership look-up: avoid a list (or tuple) where you could use a set (or dictionary)</li> <li>Iteration: avoid a function (or list comprehension) where you could use a generator (or generator expression)</li> <li>Profile: make time for performance checks by profiling your code for bottlenecks</li> </ul> <p>If you have a collection of values, your first thought may be to store them in a list.</p> In\u00a0[\u00a0]: Copied! <pre>data_list = [17999712, 2015, 'Hawkins Road', 'Linden ', 'NC', 28356]\n</pre> data_list = [17999712, 2015, 'Hawkins Road', 'Linden ', 'NC', 28356] <p>Lists are nice because they are very flexible. You can change the values in the list, including appending and removing values. But that flexibility comes at a cost. Lists are less efficient than tuples. For example, they use more memory.</p> In\u00a0[\u00a0]: Copied! <pre>import sys\n\ndata_tuple = tuple(data_list)\n\nprint(sys.getsizeof(data_list))\nprint(sys.getsizeof(data_tuple))\n</pre> import sys  data_tuple = tuple(data_list)  print(sys.getsizeof(data_list)) print(sys.getsizeof(data_tuple)) <p>Note that <code>sys.getsizeof</code> doesn't include the size of data in a container, just the size of the container. You can use it to compare data structures that have the same data in them, but not to compare different data.</p> <p>When you want to see if an element already exists in a collection of elements, neither lists nor tuples are the best choice.</p> <ul> <li>List and tuple lookup is sequential. The bigger the list, the longer look-up takes. This is called O(n) time complexity.</li> <li>Set and dictionary lookups are hashable, which means a lookup goes directly to the correct value. Lookup always takes the same amount of time, now matter how much data there is. This is called O(1) time complexity</li> </ul> <p>For example, imagine an analyst has a dataset of 1 million addresses. They also have a smaller dataset of 10,000 zip codes. They want to know which of the zip codes are associated with at least 1 of the addresses.</p> <p>One way to do that is with a list</p> In\u00a0[\u00a0]: Copied! <pre>from random import randint\naddresses_zips = [randint(10000, 99950) for _ in range(1_000_000)]\nzips_of_interest = [randint(10000, 99950) for _ in range(10_000)]\n</pre> from random import randint addresses_zips = [randint(10000, 99950) for _ in range(1_000_000)] zips_of_interest = [randint(10000, 99950) for _ in range(10_000)] In\u00a0[\u00a0]: Copied! <pre>zips_with_address_match_from_list = []\n\nfor address_zip in addresses_zips:\n    if address_zip in zips_of_interest:\n        zips_with_address_match_from_list.append(address_zip)\n\nprint(len(zips_with_address_match_from_list))\n</pre> zips_with_address_match_from_list = []  for address_zip in addresses_zips:     if address_zip in zips_of_interest:         zips_with_address_match_from_list.append(address_zip)  print(len(zips_with_address_match_from_list)) <p>A faster way is to use a set.</p> In\u00a0[\u00a0]: Copied! <pre>zips_of_interest_set = set(zips_of_interest)\n</pre> zips_of_interest_set = set(zips_of_interest) In\u00a0[\u00a0]: Copied! <pre>zips_with_address_match_from_set = []\n\nfor address_zip in addresses_zips:\n    if address_zip in zips_of_interest_set:\n        zips_with_address_match_from_set.append(address_zip)\n\nprint(len(zips_with_address_match_from_set))\nzips_with_address_match_from_set == zips_with_address_match_from_list\n</pre> zips_with_address_match_from_set = []  for address_zip in addresses_zips:     if address_zip in zips_of_interest_set:         zips_with_address_match_from_set.append(address_zip)  print(len(zips_with_address_match_from_set)) zips_with_address_match_from_set == zips_with_address_match_from_list <p>Big takeaway: Lists are appropriate when you need a collection where you can change the values, but they aren't the best choice for everything. Use a tuple if you don't need to change the values. Use a dictionary or set if you need to check if a value is in the collection.</p> <p>Regular functions and comprehensions typically store outputs into containers, like lists or dictionaries. This can take up unnecessary memory, especially when we're creating multi-step workflows with many intermediate outputs.</p> <p>In contrast, generators only hold one data item in memory at a time. A generator is a type of iterator that produces results on-demand (lazily), maintaining its state between iterations.</p> In\u00a0[\u00a0]: Copied! <pre>def massive_func():\n  \"\"\"A function that attempts to produce an infinitely long list of even numbers.\"\"\"\n  x_list = []\n  x = 0\n  while True:\n    x_list.append(x)\n    x += 2\n  return x_list\n</pre> def massive_func():   \"\"\"A function that attempts to produce an infinitely long list of even numbers.\"\"\"   x_list = []   x = 0   while True:     x_list.append(x)     x += 2   return x_list In\u00a0[\u00a0]: Copied! <pre># Calling this function will run out of space\nfor x in massive_func():\n    print(x)\n</pre> # Calling this function will run out of space for x in massive_func():     print(x) In\u00a0[\u00a0]: Copied! <pre>def massive_gen():\n  \"\"\"A generator that produces an infinitely long stream of even numbers.\"\"\"\n  x = 0\n  while True:\n    yield x\n    x += 2\n\n# Calling this function will run out of time\nfor x in massive_gen():\n  print(x)\n</pre> def massive_gen():   \"\"\"A generator that produces an infinitely long stream of even numbers.\"\"\"   x = 0   while True:     yield x     x += 2  # Calling this function will run out of time for x in massive_gen():   print(x) <p>What goes for functions, also goes for list comprehensions. You can often use a generator expression in place of a list comprehension. We've already seen an example of a generator expression in the n-dimensional distance function:</p> In\u00a0[\u00a0]: Copied! <pre>coords = (1, 1, 1, 1)\nsum(d ** 2 for d in coords)\n</pre> coords = (1, 1, 1, 1) sum(d ** 2 for d in coords)  <p>Compare that example to one that uses a list comprehension:</p> In\u00a0[\u00a0]: Copied! <pre>coords = (1, 1, 1, 1)\nsum([d ** 2 for d in coords])\n</pre> coords = (1, 1, 1, 1) sum([d ** 2 for d in coords]) <p>The <code>sum</code> function operates by looping over an iterable and adding the value to a running total. In the first case, the iterable is a generator that produces a single value at a time.</p> <p>In the second case, the list comprension loops over <code>coords</code> to produce a list where every value is stored in memory. Then the <code>sum</code> function loops over that list.</p> <p>An important limitation of generators is that because they produce a single value at a time and then forget about it, you cannot reuse them.</p> In\u00a0[\u00a0]: Copied! <pre>generator = (d ** 2 for d in coords)\nsum(generator)\n</pre> generator = (d ** 2 for d in coords) sum(generator) In\u00a0[\u00a0]: Copied! <pre>max(generator)\n</pre> max(generator) <p>Big Takeaway: If you're only going to use a value once, you should probably use a generator. If you need to use it again, you probabably need to store it in something like a tuple or list.</p> <p>Profiling is any technique used to measure the performance of your code, such as its speed or resource usage. There are dozens of tools available for profiling, but we'll focus on two:</p> <ol> <li>Check memory use: Use <code>tracemalloc</code> to check the memory usage of code.</li> <li>Spot-profile your code: Use the <code>timeit</code> notebook magic to perform some basic profiling by cell or by line.</li> </ol> <p>To make profiling easier, the cell below defines functions for calculating a sum on a generator expression and on a list comprehension. Both functions will be called with a very large number of coordinates to make profile differences more obvious.</p> In\u00a0[\u00a0]: Copied! <pre>coords = (1, 1) * 1_000_000\ndef sum_generator(coords):\n    return sum(d ** 2 for d in coords)\n\ndef sum_list_comprehension(coords):\n    return sum([d ** 2 for d in coords])\n</pre> coords = (1, 1) * 1_000_000 def sum_generator(coords):     return sum(d ** 2 for d in coords)  def sum_list_comprehension(coords):     return sum([d ** 2 for d in coords]) <p>The cells below uses <code>tracemalloc</code> to capture information about memory usage for the the two versions of the function.</p> <p>You do need to restart the kernel between runs of these cells, to ensure <code>tracemalloc</code> isn't counting information stored in memory from a previous cell run.</p> In\u00a0[\u00a0]: Copied! <pre>import tracemalloc\n\ntracemalloc.start()\n\nsum_generator(coords)\n\ncurrent, peak = tracemalloc.get_traced_memory()\nprint(peak)\n</pre> import tracemalloc  tracemalloc.start()  sum_generator(coords)  current, peak = tracemalloc.get_traced_memory() print(peak) In\u00a0[\u00a0]: Copied! <pre>import tracemalloc\n\ntracemalloc.start()\n\nsum_list_comprehension(coords)\n\ncurrent, peak = tracemalloc.get_traced_memory()\nprint(peak)\n</pre> import tracemalloc  tracemalloc.start()  sum_list_comprehension(coords)  current, peak = tracemalloc.get_traced_memory() print(peak) <p>The <code>timeit</code> module measures the execution time of a selection of code. Among the ways you'll see it written are \"magic\" commands in notebooks.</p> <p><code>%%timeit</code> is a form of cell magic. It measures the execution time of the entire notebook cell.</p> In\u00a0[\u00a0]: Copied! <pre>%%timeit\nsum_generator(coords)\n</pre> %%timeit sum_generator(coords) In\u00a0[\u00a0]: Copied! <pre>%%timeit\nsum_list_comprehension(coords)\n</pre> %%timeit sum_list_comprehension(coords) <p>If you just want to check the timeing for a single line, you can use the <code>%timeit</code> line magic. That's useful if you have some code that takes some time to run, but you don't want it affecting the <code>timeit</code> results. Compare the use of cell magic and line magic in the next two cells.</p> In\u00a0[\u00a0]: Copied! <pre>%%timeit\nfrom time import sleep\n\nsleep(1)\n\nsum_list_comprehension(coords)\n</pre> %%timeit from time import sleep  sleep(1)  sum_list_comprehension(coords) In\u00a0[\u00a0]: Copied! <pre>from time import sleep\n\nsleep(1)\n\n%timeit sum_list_comprehension(coords)\n</pre> from time import sleep  sleep(1)  %timeit sum_list_comprehension(coords) <p>Big takeaway: You can use your knowledge of Python to make some predictions about where performance bottlenecks are occuring in your code. But you should check to be sure, because those bottlenecks frequently show up in unexpected places.</p> <p>The exercises below invite you to practice applying the different strategies outlined above. They follow the order of the concepts presented, and you'll need to at least run the code in #3 before you attempt #4 or #5, since they rely on the function definitions in #3. You can otherwise attempt them in any order. Start with the ones that seem most applicable to the work you need to do.</p> <p>You can find example answers in the ExerciseAnswers.ipynb notebook.</p> <p>The code below creates a list containing all years in a research study timeframe, from 1900 to 2030.</p> <p>The values in this collection will not need to be changed because the study will always use this timeframe.</p> In\u00a0[\u00a0]: Copied! <pre>import sys\n\ndef list_from_range(start, end):\n  \"\"\"Create a list from a range of values\"\"\"\n  return list(range(start, end + 1))\n\nstart = 1900\nend = 2030\n\nstudyYears = list_from_range(start, end)\n\nprint(studyYears)\nprint(\"Bytes used: \", sys.getsizeof(studyYears))\n</pre> import sys  def list_from_range(start, end):   \"\"\"Create a list from a range of values\"\"\"   return list(range(start, end + 1))  start = 1900 end = 2030  studyYears = list_from_range(start, end)  print(studyYears) print(\"Bytes used: \", sys.getsizeof(studyYears)) <p>Write a different implementation using a different storage option and demonstrate that option uses less memory.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>The code below assigns a collection of placenames to a list. Then, it checks whether a placename is in the list. If not, the placename is reported missing.</p> <p>If you have 1 million placenames to look up and 6 names in the list, that\u2019s up to 6 million checks.</p> In\u00a0[\u00a0]: Copied! <pre>placeNames_list = [\"Kinshasa\", \"Duluth\", \"Uruguay\"] * 1_000_000\n\n# O(n) list look-up\nif \"Dinkytown\" not in placeNames_list:\n    print(\"Missing.\")  \n</pre> placeNames_list = [\"Kinshasa\", \"Duluth\", \"Uruguay\"] * 1_000_000  # O(n) list look-up if \"Dinkytown\" not in placeNames_list:     print(\"Missing.\")   <p>Write a different implementation using a storage option that allows quicker checks for membership at scale.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>The code below uses a generator to create vertices for triangles from a random selection. It also defines a function for calculating the area of a polygon from its vertices.</p> In\u00a0[\u00a0]: Copied! <pre>from itertools import cycle\nfrom random import randint\n\nclass Random_Vertex:\n    def __init__(self):\n        self.x = randint(0, 100)\n        self.y = randint(0, 100)\n    \ndef generate_polygon_vertices(num_polygons, num_sides):\n    for _ in range(num_polygons):\n        vertices = (Random_Vertex() for _ in range(num_sides))\n        yield vertices\n\ndef calculate_area(vertices):\n    subtotals = []\n    vertex_cycle = cycle(vertices)\n    next(vertex_cycle)\n    for vertex in vertices:\n        next_vertex = next(vertex_cycle)\n        subtotal = vertex.x * next_vertex.y - vertex.y * next_vertex.x\n        subtotals.append(subtotal)\n    area = abs(sum(subtotals) / 2)\n    return area\n</pre> from itertools import cycle from random import randint  class Random_Vertex:     def __init__(self):         self.x = randint(0, 100)         self.y = randint(0, 100)      def generate_polygon_vertices(num_polygons, num_sides):     for _ in range(num_polygons):         vertices = (Random_Vertex() for _ in range(num_sides))         yield vertices  def calculate_area(vertices):     subtotals = []     vertex_cycle = cycle(vertices)     next(vertex_cycle)     for vertex in vertices:         next_vertex = next(vertex_cycle)         subtotal = vertex.x * next_vertex.y - vertex.y * next_vertex.x         subtotals.append(subtotal)     area = abs(sum(subtotals) / 2)     return area <p>The code below uses the code above to generate 1 million triangles. You want to find out the area of the largest triangle. The code below does this with a list comprehension, which holds all 1 million area values in memory.</p> In\u00a0[\u00a0]: Copied! <pre>triangles = generate_polygon_vertices(1_000_000, 3)\nmax([calculate_area(triangle) for triangle in triangles])\n</pre> triangles = generate_polygon_vertices(1_000_000, 3) max([calculate_area(triangle) for triangle in triangles])  <p>Rewrite the code above to use less memory.</p> <p>Hint: The easiest fix is to replace the list comprehension with a generator expression. Harder would be writing your own generator using the <code>yield</code> statement</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>Change both cells below to use <code>tracemalloc</code> to compare their memory use.</p> <p>Hint: Because the notebook keeps many variables in memory, you will want to restart the notebook kernel between running the cell to get a valid comparison. That means you will need to re-run the cell that defines the <code>generate_polygon_vertices</code> generator and <code>calculate_area</code> function.</p> In\u00a0[\u00a0]: Copied! <pre># Using lists\ntriangles = generate_polygon_vertices(1_000, 3)\nmax([calculate_area(triangle) for triangle in triangles])\n</pre> # Using lists triangles = generate_polygon_vertices(1_000, 3) max([calculate_area(triangle) for triangle in triangles]) In\u00a0[\u00a0]: Copied! <pre># Using a generator expression\ntriangles = generate_polygon_vertices(1_000, 3)\nmax(calculate_area(triangle) for triangle in triangles)\n</pre> # Using a generator expression triangles = generate_polygon_vertices(1_000, 3) max(calculate_area(triangle) for triangle in triangles) <p>Change both cells below to use <code>timeit</code> to compare their execution time.</p> In\u00a0[\u00a0]: Copied! <pre># Using a list\ntriangles = generate_polygon_vertices(1_000, 3)\nmax([calculate_area(triangle) for triangle in triangles])\n</pre> # Using a list triangles = generate_polygon_vertices(1_000, 3) max([calculate_area(triangle) for triangle in triangles]) In\u00a0[\u00a0]: Copied! <pre># Using a generator expression\ntriangles = generate_polygon_vertices(1_000, 3)\nmax(calculate_area(triangle) for triangle in triangles)\n</pre> # Using a generator expression triangles = generate_polygon_vertices(1_000, 3) max(calculate_area(triangle) for triangle in triangles)"},{"location":"PerformanceMemory/#optimize-performance-and-memory-use","title":"Optimize Performance and Memory Use\u00b6","text":""},{"location":"PerformanceMemory/#use-fewer-lists","title":"Use fewer lists\u00b6","text":""},{"location":"PerformanceMemory/#membership-look-up-sequential-vs-hashable","title":"Membership look-up: sequential vs. hashable\u00b6","text":""},{"location":"PerformanceMemory/#use-more-generators","title":"Use more generators\u00b6","text":""},{"location":"PerformanceMemory/#profile-dont-guess","title":"Profile, don't guess\u00b6","text":""},{"location":"PerformanceMemory/#check-memory-use","title":"Check memory use\u00b6","text":""},{"location":"PerformanceMemory/#spot-check-speed-with-timeit","title":"Spot-check speed with <code>%%timeit</code>\u00b6","text":""},{"location":"PerformanceMemory/#exercises","title":"Exercises\u00b6","text":""},{"location":"PerformanceMemory/#1-use-the-right-data-structure-for-immutable-sequences","title":"1) Use the right data structure for immutable sequences\u00b6","text":""},{"location":"PerformanceMemory/#2-use-the-right-data-structure-for-membership-lookup","title":"2) Use the right data structure for membership lookup\u00b6","text":""},{"location":"PerformanceMemory/#3-use-generators","title":"3) Use generators\u00b6","text":""},{"location":"PerformanceMemory/#4-check-memory-use-of-lists-vs-generators","title":"4) Check memory use of lists vs. generators\u00b6","text":""},{"location":"PerformanceMemory/#5-compare-execution-speed-of-lists-vs-generators","title":"5) Compare execution speed of lists vs. generators\u00b6","text":""},{"location":"tryhard/","title":"Don't try so hard","text":"<p>When presented with a problem, our first instinct might be to write code that reflects how we would solve the problem manually. That's good because we can take advantage of our existing knowledge. But it's also bad because it's likely to be harder to implement than a solution that takes full advantages of Python's capabilities.</p> <p>You are probably working harder than you need to when you implement solutions that match your manual process. For many types of problems, Python has solved them already. Learning the Pythonic way to address a problem will be easier than coming up with your own. It will also be easier for other people to understand your code, because you are using the well-known idioms of Python instead of your own idiosyncratic implementation.</p> <p>An analyst has a tuple of three values that represent the x, y, and z coordinates of a location. The analyst has a distance function that takes three arguments, one for each coordinate.</p> In\u00a0[\u00a0]: Copied! <pre>coordinates = (2, 5, 4)\n\ndef distance_from_origin(x, y, z):\n    return (x**2 + y**2 + z**2) ** 0.5\n</pre> coordinates = (2, 5, 4)  def distance_from_origin(x, y, z):     return (x**2 + y**2 + z**2) ** 0.5 <p>The analyst needs to pass the values from the tuple to the function. One way to do that is to use the index of each value with bracket notation.</p> In\u00a0[\u00a0]: Copied! <pre>x = coordinates[0]\ny = coordinates[1]\nz = coordinates[2]\n\ndistance_from_origin(x, y, z)\n</pre> x = coordinates[0] y = coordinates[1] z = coordinates[2]  distance_from_origin(x, y, z) <p>That works, but it has two problems:</p> <ul> <li>Repetition of <code>coodinates</code> is error prone and tough to refactor.</li> <li>Overuse of brackets makes code harder to read.</li> </ul> <p>You can use unpacking to fix both problems.</p> In\u00a0[\u00a0]: Copied! <pre>x, y, z = coordinates\n\ndistance_from_origin(x, y, z)\n</pre> x, y, z = coordinates  distance_from_origin(x, y, z) <p>Variable unpacking takes a collection of values on the right-hand side of <code>=</code> and assigns each value in order to an equal number of names on the left hand side. Importantly, the number of names on the left must match the number of values in the collection on the right.</p> In\u00a0[\u00a0]: Copied! <pre>x, y, z, m = coordinates\n</pre> x, y, z, m = coordinates In\u00a0[\u00a0]: Copied! <pre>x, y = coordinates\n</pre> x, y = coordinates <p>Unpacking to names is useful, but you can go a step further when the values you need to unpack will be passed to a function or class constructor.</p> In\u00a0[\u00a0]: Copied! <pre>distance_from_origin(*coordinates)\n</pre> distance_from_origin(*coordinates) <p>The <code>*</code> in front of the variable name unpacks the values so that each value in order is assigned to the parameters of the function.</p> <p>One disadvantage of unpacking a collection into arguments this way is that it relies on parameter order. That means it only works when you can use positional arguments and doesn't work when you need to specify keyword arguments.</p> <p>But if the values to unpack are in a dictionary where each key matches a parameter name, you can unpack them as keyword arguments with <code>**</code>. Then the order of values no longer matters.</p> In\u00a0[\u00a0]: Copied! <pre>coordinates_dict = {\n    \"z\": 4,\n    \"y\": 5,\n    \"x\": 2\n}\n\ndistance_from_origin(**coordinates_dict)\n</pre> coordinates_dict = {     \"z\": 4,     \"y\": 5,     \"x\": 2 }  distance_from_origin(**coordinates_dict) <p>Big Takeaway: Unpacking reduces the amount of code you have to write and makes your code easier to read. Take advantage of it wherever you can.</p> <p>An analyst has a list of population densities in people per km<sup>2</sup>. They need to transform those values in people per mi<sup>2</sup>.</p> <p>One way to do that is to loop over all the values, apply a transformation function, and append the transformed value to a new list.</p> In\u00a0[\u00a0]: Copied! <pre>people_per_km2 = (5, 40, 200, 17, 8000)\npeople_per_mi2 = []\nfor density in people_per_km2:\n    mi2_density = density * 2.59\n    people_per_mi2.append(mi2_density)\npeople_per_mi2\n</pre> people_per_km2 = (5, 40, 200, 17, 8000) people_per_mi2 = [] for density in people_per_km2:     mi2_density = density * 2.59     people_per_mi2.append(mi2_density) people_per_mi2  <p>That code is correct, but it is more verbose than necessary, which can hurt readability.</p> <p>When you see a pattern where you loop over something, do something to the values, then append new values to an empty list, you should consider replacing it with a list comprehension.</p> In\u00a0[\u00a0]: Copied! <pre>people_per_mi2 = [density * 2.59 for density in people_per_km2]\npeople_per_mi2\n</pre> people_per_mi2 = [density * 2.59 for density in people_per_km2] people_per_mi2 <p>List comprehensions are more readable, but only for people who are familiar with them, so be aware of your audience when using them. They are also a little bit faster than using a <code>for</code> loop.</p> <p>But comprehensions are bad when the transformation is complex. Imagine we have a list of quantitative values that we want to transform to qualitative values.</p> <p>List comprehensions let you do that in a single line. But it is an abomination.</p> In\u00a0[\u00a0]: Copied! <pre>quantitative = [100, 50, 317, 21]\n\nqualitative = [\"S\" if val &lt; 100 else \"M\" if val &lt;= 200 else \"L\" for val in quantitative]\n</pre> quantitative = [100, 50, 317, 21]  qualitative = [\"S\" if val &lt; 100 else \"M\" if val &lt;= 200 else \"L\" for val in quantitative]  <p>For more complex operations, it is much better to use an explicit loop.</p> In\u00a0[\u00a0]: Copied! <pre>qualitative = []\n\nfor val in quantitative:\n    if val &lt; 100:\n        qualitative.append(\"S\")\n    elif val &lt;= 200:\n        qualitative.append(\"M\")\n    else:\n        qualitative.append(\"L\")\nqualitative\n</pre> qualitative = []  for val in quantitative:     if val &lt; 100:         qualitative.append(\"S\")     elif val &lt;= 200:         qualitative.append(\"M\")     else:         qualitative.append(\"L\") qualitative <p>An analyst has tract-level census data where each tract has three values:</p> <ul> <li>Land Area in km<sup>2</sup></li> <li>Population</li> </ul> <p>An analyst has tract-level census data records. Each tract has two values: population and households. The analyst could model a single tract as a dictionary.</p> In\u00a0[\u00a0]: Copied! <pre>tract1 = {\n    \"population\": 1000,\n    \"households\": 500\n}\n</pre> tract1 = {     \"population\": 1000,     \"households\": 500 } <p>That looks appropriate because it clearly links each value to a key that explains what the value means. But a dictionary is usually not a good data structure for a single record from a table. For one thing, there is a substantial amount of repetition if you need to model many records.</p> In\u00a0[\u00a0]: Copied! <pre>tract2 = {\n    \"population\": 2000,\n    \"households\": 800\n}\n\ntract3 = {\n    \"population\": 5000,\n    \"households\": 3000\n}\n</pre> tract2 = {     \"population\": 2000,     \"households\": 800 }  tract3 = {     \"population\": 5000,     \"households\": 3000 } <p>Another problem is that dictionaries are mutable, which means the keys can change and cause the dictionary to no longer fit the same data schema.</p> In\u00a0[\u00a0]: Copied! <pre>del tract2[\"households\"]\ntract2\n</pre> del tract2[\"households\"] tract2 <p>Dictionaries are optimized for fast access of a value by key. This is not usually an important goal for an individual record. Using a dictionary to model records is unecessarily hard. A better data structure for a record is a tuple.</p> In\u00a0[\u00a0]: Copied! <pre>tract1 = (1000, 500)\ntract2 = (2000, 800)\ntract3 = (5000, 3000)\n</pre> tract1 = (1000, 500) tract2 = (2000, 800) tract3 = (5000, 3000) <p>The problem with tuples, however, is the lack of context for each value represents. An even better data structure for a record is a named tuple, which you can import from the standard library.</p> <p>To use a named tuple, create a class that inherits from <code>NamedTuple</code>. For this kind of class, you only need to specify the field names and the datatype the values in each field should have. You can then create instances of that named tuple by passing the appropriate values to the constructor.</p> In\u00a0[\u00a0]: Copied! <pre>from typing import NamedTuple\n\nclass Tract(NamedTuple):\n    population: int\n    households: int\n\ntract1 = Tract(1000, 500)\ntract2 = Tract(2000, 800)\ntract3 = Tract(5000, 3000)\n</pre> from typing import NamedTuple  class Tract(NamedTuple):     population: int     households: int  tract1 = Tract(1000, 500) tract2 = Tract(2000, 800) tract3 = Tract(5000, 3000) <p>You can access the value in a field using dot notation.</p> In\u00a0[\u00a0]: Copied! <pre>tract1.households\n</pre> tract1.households <p>Big takeaway: The standard library has classes and functions that make your life easier without having to install additional packages. You should use them more. Named tuples are just one example. The official documentation lists them all, but some highlights include:</p> <ul> <li>csv for working with csv files</li> <li>dataclasses for creating dataclasses (like <code>NamedTuple</code>, but editable)</li> <li>datetime for working with dates and times</li> <li>itertools for efficient looping</li> <li>math for Mathematical functions</li> <li>pprint for nicely printing complex data structures</li> <li>pathlib and os.path for working with file paths</li> </ul> <p>The analyst wants to know the average number of people per household across all tracts. That is not the same as averaging the number of people per household per tract. The analyst needs to divide the total population across tracts by the total number of households across tracts.</p> <p>One way to get the right answer is to loop over each tract, keeping a running total of the population househould values. Then calculate the the ratio.</p> In\u00a0[\u00a0]: Copied! <pre>population = 0\nhouseholds = 0\ntracts = [tract1, tract2, tract3]\nfor tract in tracts:\n    population += tract.population\n    households += tract.households\n\npopulation / households\n</pre> population = 0 households = 0 tracts = [tract1, tract2, tract3] for tract in tracts:     population += tract.population     households += tract.households  population / households <p>That gives the correct answer, but keeping running totals obscures the goal, which is to create the sums of the total population and households across tracts.</p> <p>Summing values is a common pattern, and for many common patterns, Python has some built-in capability to make it easier to accomplish. Built-ins differ from the standard library in that you don't have to import anything to get access to built-ins.</p> <p>Code that is is considered Pythonic makes good use of these built-in capabilities. In this case, there is the <code>sum</code> function. This has the advantage of making it more explicit to the reader that the code is summing values in a collection.</p> In\u00a0[\u00a0]: Copied! <pre>population_values = []\nhousehold_values = []\ntracts = [tract1, tract2, tract3]\nfor tract in tracts:\n    population_values.append(tract.population)\n    household_values.append(tract.households)\n\nsum(population_values) / sum(household_values)\n</pre> population_values = [] household_values = [] tracts = [tract1, tract2, tract3] for tract in tracts:     population_values.append(tract.population)     household_values.append(tract.households)  sum(population_values) / sum(household_values) <p>While you could use a list comprehension, there's actually an even better way.</p> <p>Imagine each tract is a row in a table that has population and household fields. We want to get the sum of each column. But we don't actually have columns, we only have the rows.</p> <p>This turns out to be a very common type of problem where we have a group of pairs (or triples, etc), and we want a pair (or triple, etc) of groups. For these problems, use the built-in <code>zip</code> function.</p> <p>By using <code>zip</code>, you can save yourself a little bit of typing and a significant amount of thinking about the correct implementation. Using <code>zip</code> also makes your code easier to explain to other people familiar with Python because they don't have to reason through your implementation to make sure it's been done correctly.</p> In\u00a0[\u00a0]: Copied! <pre>population_values, household_values = zip(tract1, tract2, tract3)\n\nsum(population_values) / sum(household_values)\n</pre> population_values, household_values = zip(tract1, tract2, tract3)  sum(population_values) / sum(household_values) <p>Big Takeaway: Python built-ins can make your life easier, without even having to import additional libraries. <code>sum</code>, list comprehensions, and <code>zip</code> are among the more useful built-in capabilities of Python you should be using more. The official documentation has the complete list, but some other useful built-in functions include:</p> <ul> <li><code>abs</code> for returning the absolute value of a number.</li> <li><code>all</code> and <code>any</code> for testing the truth of a collection of values.</li> <li><code>dir</code> for listing the attributes of an object</li> <li><code>enumerate</code> for getting both the index and a value from a collection. Useful for complex loops.</li> <li><code>help</code> for getting information about a Python object.</li> <li><code>isinstance</code> and <code>type</code> for getting information about an object's type</li> <li><code>len</code> for getting the length of a collection, such as a string or list.</li> <li><code>max</code> and <code>min</code> for getting the maximum or minimum value from a group of values.</li> <li><code>open</code> for opening files.</li> <li><code>range</code> for creating a collection of values in a given range.</li> </ul> <p>The analyst writes a function to calculate the population density in people per km<sup>2</sup> of land area.</p> In\u00a0[\u00a0]: Copied! <pre>tract1 = {\n    \"land_area\": 20,\n    \"population\": 1000\n}\n</pre> tract1 = {     \"land_area\": 20,     \"population\": 1000 } In\u00a0[\u00a0]: Copied! <pre>def pop_density(tract):\n    return tract[\"population\"] / tract[\"land_area\"]\n\npop_density(tract1)\n</pre> def pop_density(tract):     return tract[\"population\"] / tract[\"land_area\"]  pop_density(tract1) <p>There are a few ways this could go wrong. What if the record is missing a <code>population</code> key because no people live there?</p> In\u00a0[\u00a0]: Copied! <pre>tract2 = {\n    \"land_area\": 10\n}\n\npop_density(tract2)\n</pre> tract2 = {     \"land_area\": 10 }  pop_density(tract2) <p>What if it's missing a <code>land_area</code> key because it's all water?</p> In\u00a0[\u00a0]: Copied! <pre>tract3 = {\n    \"population\": 0\n}\npop_density(tract3)\n</pre> tract3 = {     \"population\": 0 } pop_density(tract3) <p>What if it has a land area value of 0 because it's all water?</p> In\u00a0[\u00a0]: Copied! <pre>tract4 = {\n    \"land_area\": 0,\n    \"population\": 0\n}\npop_density(tract4)\n</pre> tract4 = {     \"land_area\": 0,     \"population\": 0 } pop_density(tract4) <p>One way to deal with potential bad values to is to check for them ahead of time with conditional logic.</p> In\u00a0[\u00a0]: Copied! <pre>def pop_density2(tract):\n    if \"population\" not in tract.keys():\n        return 0\n    elif \"land_area\" not in tract.keys():\n        return 0\n    elif tract[\"land_area\"] == 0:\n        return 0\n    else:\n        return tract[\"population\"] / tract[\"land_area\"]\n        \nfor tract in (tract1, tract2, tract3, tract4):\n    print(pop_density2(tract))\n</pre> def pop_density2(tract):     if \"population\" not in tract.keys():         return 0     elif \"land_area\" not in tract.keys():         return 0     elif tract[\"land_area\"] == 0:         return 0     else:         return tract[\"population\"] / tract[\"land_area\"]          for tract in (tract1, tract2, tract3, tract4):     print(pop_density2(tract)) <p>But using conditional logic like this is not great. You need to put in the checks before you get to your core logic, which hurts both performance and readability.</p> <p>You will also inevitably run into edge cases that you didn't anticipate. What if a tract with no people has the <code>population</code> key set to <code>None</code>?</p> In\u00a0[\u00a0]: Copied! <pre>tract5 = {\n    \"land_area\": 20,\n    \"population\": None\n}\n\npop_density2(tract5)\n</pre> tract5 = {     \"land_area\": 20,     \"population\": None }  pop_density2(tract5) <p>Instead of writing an exploding mess of spaghetti code to deal with a never-ending parade of edge cases, it is better to use <code>try</code> and <code>except</code>. Python will attempt to run the code in the <code>try</code> block. If that code throws an exception, Python will run the code in the <code>except</code> block that matches the type of exception.</p> In\u00a0[\u00a0]: Copied! <pre>def pop_density3(tract):\n    try:\n        return tract[\"population\"] / tract[\"land_area\"]\n    except (KeyError, ZeroDivisionError, TypeError):\n        return 0\n\nfor tract in (tract1, tract2, tract3, tract4, tract5):\n    print(pop_density3(tract))\n</pre> def pop_density3(tract):     try:         return tract[\"population\"] / tract[\"land_area\"]     except (KeyError, ZeroDivisionError, TypeError):         return 0  for tract in (tract1, tract2, tract3, tract4, tract5):     print(pop_density3(tract)) <p>This code is still somewhat fragile. For example, it won't correctly handle records that store values as strings instead of numeric types. But it is usually easier to deal with those complexities as they arise by using <code>try</code>/<code>except</code> rather than <code>if</code> statements. If you do really need some complex conditional logic to handle edge cases, banish it to the <code>except</code> block instead of distracting the reader by putting it up front.</p> <p>Big takeaway: You can just try things. It's usually easier, faster, and more readable to put the common case in a <code>try</code> block, and handle exceptions for edge cases where the common case doesn't work.</p> <p>If you want to open a file with Python, you had better make sure you close it, or bad things can happen.</p> In\u00a0[\u00a0]: Copied! <pre>f = open(\"file.txt\", \"w\")\nf.write(\"Here is some text\")\nf.close()\n</pre> f = open(\"file.txt\", \"w\") f.write(\"Here is some text\") f.close() <p>This has two problems:</p> <ul> <li>It's easy to forget to close it, especially because most of the time it doesn't actually cause problems when you don't</li> <li>If your code crashes after you open the file but before you close it, it doesn't close properly</li> </ul> <p>Instead, you may already know you should do it like this so that the file closes automatically:</p> In\u00a0[\u00a0]: Copied! <pre>with open(\"file.txt\", \"w\") as f:\n    f.write(\"Here is some different text\")\n</pre> with open(\"file.txt\", \"w\") as f:     f.write(\"Here is some different text\") <p>This isn't magic, it's a context manager. A context manager provides setup and tear down code. The setup code always runs at the beginning of the <code>with</code> block before anything inside the block. The teardown code always runs when the <code>with</code> block exits, even if it exited because of an error.</p> <p>Context managers are useful for reducing the amount of repetitive boilerplate code you have to write to make sure things are set up and torn down correctly.</p> <p>For example, you may want to write some data to a database, but you want to make sure the transaction gets rolled back if there's a problem with some part of the write.</p> <p>The code below:</p> <ul> <li>Connects to a sqlite database</li> <li>Puts the data writing code into a <code>try</code> block using an explicit transaction</li> <li>Handles errors in the <code>except</code> block by rolling back the transation (<code>conn.commit</code> is never reached if there is an error before that)</li> <li>Closes the connection</li> </ul> In\u00a0[\u00a0]: Copied! <pre>import sqlite3\n\nconn = sqlite3.connect(\"test.db\")\n\ntry:\n    cursor = conn.cursor()\n    cursor.execute(\"BEGIN TRANSACTION\")\n    cursor.execute(\"CREATE TABLE IF NOT EXISTS test (id INTEGER PRIMARY KEY, country TEXT)\")\n    cursor.execute(\"INSERT INTO test (country) VALUES('Argentina')\")\n    conn.commit()\nexcept Exception as e:\n    print(f\"Error {e}: Rolling back transaction\")\n    conn.rollback\n\nconn.close()\n</pre> import sqlite3  conn = sqlite3.connect(\"test.db\")  try:     cursor = conn.cursor()     cursor.execute(\"BEGIN TRANSACTION\")     cursor.execute(\"CREATE TABLE IF NOT EXISTS test (id INTEGER PRIMARY KEY, country TEXT)\")     cursor.execute(\"INSERT INTO test (country) VALUES('Argentina')\")     conn.commit() except Exception as e:     print(f\"Error {e}: Rolling back transaction\")     conn.rollback  conn.close() <p>It turns out that sqlite has a context manager that creates the connection and rolls back transactions if there's an exception.</p> <p>It's important to know exactly what kind of setup and teardown a particular context manager does. This particular context manager creates the connection, but it does not automatically close it. You still have to remember to close it yourself.</p> In\u00a0[\u00a0]: Copied! <pre>db_path = \"test.db\"\n\nwith sqlite3.connect(db_path) as conn:\n    cursor = conn.cursor()\n    cursor.execute(\"CREATE TABLE IF NOT EXISTS test (id INTEGER PRIMARY KEY, country TEXT)\")\n    cursor.execute(\"INSERT INTO test (country) VALUES('Argentina')\")\n    conn.commit()\n\nconn.close()\n</pre> db_path = \"test.db\"  with sqlite3.connect(db_path) as conn:     cursor = conn.cursor()     cursor.execute(\"CREATE TABLE IF NOT EXISTS test (id INTEGER PRIMARY KEY, country TEXT)\")     cursor.execute(\"INSERT INTO test (country) VALUES('Argentina')\")     conn.commit()  conn.close() <p>Big takeaway: If you are working with objects that support context managers, you should use those context managers. Pay attention to how the context manager works though, because it may not do everything you expect.</p> <p>The exercises below invite you to practice applying the different strategies outlined above. They follow the order of the concepts presented, but you can attempt them in any order. Start with the ones that seem most applicable to the work you need to do.</p> <p>You can find example answers in the ExerciseAnswers.ipynb notebook.</p> In\u00a0[\u00a0]: Copied! <pre>counties = [\"Anoka\", \"Dakota\", \"Carver\", \"Hennepin\", \"Ramsey\", \"Scott\", \"Washington\"]\nfor county in counties:\n    print(county)\n</pre> counties = [\"Anoka\", \"Dakota\", \"Carver\", \"Hennepin\", \"Ramsey\", \"Scott\", \"Washington\"] for county in counties:     print(county) <p>Write a different implementation that uses unpacking to print each value on a separate line using a single call to the <code>print</code> function instead of a loop.</p> <p>Hint: The <code>print</code> function's first parameter is <code>*objects</code>, which is accepts any number of positional arguments (similar to <code>*args</code> in other functions). These arguments are what will be printed. The second parameter is <code>sep</code>, which defines the character to put in between the values to print. The default value of <code>sep</code> is a single space (<code>' '</code>), but it could be a newline character (<code>'\\n'</code>).</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>record = {\n    \"total_population\": 5000,\n    \"population_in_poverty\": 200\n}\n\nrecord[\"total_population\"] = 6000\n\nprint(record)\n</pre> record = {     \"total_population\": 5000,     \"population_in_poverty\": 200 }  record[\"total_population\"] = 6000  print(record) <p>This pattern cannot be implented using a named tuple, because named tuples are immutable. A data class is a standard library class that is similar to a named tuple, but it can be editable. Write a different implementation of the code above to use data classes instead of dictionaries</p> <p>Hint: The official Python documentation may be hard to understand. You may want to search for a tutorial on data classes specifically.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>from random import randint\n\nnums = [randint(-1000, 1000) for i in range(20)]\n</pre> from random import randint  nums = [randint(-1000, 1000) for i in range(20)] <p>The code below finds the maximum and minimum values of <code>nums</code> using conditional logic and explicit comparisons to running values.</p> In\u00a0[\u00a0]: Copied! <pre>min_num = 1000\nmax_num = -1000\n\nfor num in nums:\n    if num &gt; max_num:\n        max_num = num\n    if num &lt; min_num:\n        min_num = num\n\nprint(max_num, min_num)\n</pre> min_num = 1000 max_num = -1000  for num in nums:     if num &gt; max_num:         max_num = num     if num &lt; min_num:         min_num = num  print(max_num, min_num) <p>Write a different implementation that uses the built-in <code>max</code> and <code>min</code> functions instead.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>from typing import NamedTuple\n\nclass Record(NamedTuple):\n    total_population: int\n    population_in_poverty: int\n\nrecord1 = Record(5000, 2000)\nrecord2 = Record(200, 10)\nrecord3 = Record(\"400\", \"30\")\n</pre> from typing import NamedTuple  class Record(NamedTuple):     total_population: int     population_in_poverty: int  record1 = Record(5000, 2000) record2 = Record(200, 10) record3 = Record(\"400\", \"30\") <p>The code below calculates the poverty rate, first checking that the values in the record are the correct type, and transforming them if not.</p> In\u00a0[\u00a0]: Copied! <pre>def poverty_rate(record):\n    total_pop, pop_in_poverty = record\n    if not isinstance(total_pop, int):\n        total_pop = int(record.total_population)\n    if not isinstance(pop_in_poverty, int):\n        pop_in_poverty = int(record.population_in_poverty)\n    return pop_in_poverty / total_pop\n\nfor record in (record1, record2, record3):\n    print(poverty_rate(record))\n</pre> def poverty_rate(record):     total_pop, pop_in_poverty = record     if not isinstance(total_pop, int):         total_pop = int(record.total_population)     if not isinstance(pop_in_poverty, int):         pop_in_poverty = int(record.population_in_poverty)     return pop_in_poverty / total_pop  for record in (record1, record2, record3):     print(poverty_rate(record)) <p>Write a different implementation that doesn't use <code>if</code> to check datatypes ahead of time.</p> <p>Hint: You may find it useful to first write the code without any error handling to see what type of error occurs.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>For an even better way to solve this kind of problem, look into Pydantic models. These models are not built-in or in the standard library, so you have to install the Pydantic library to get them. Pydantic models are like named tuples that guarantee the records will have the correct data type.</p> <p>The code below opens <code>data.csv</code> and writes some information to the file. Then an exception occurs before the file is closed. The code creates <code>data.csv</code> if it didn't exist before, but if you open the file, you will notice that the data has not been written to the file (In a Google Colab notebook, there is a files icon on the left where you can double-click to open a file in the web interface)</p> In\u00a0[\u00a0]: Copied! <pre>f = open(\"data.csv\", \"w\")\nf.write(\"Important data\")\nraise ValueError\nf.close()\n</pre> f = open(\"data.csv\", \"w\") f.write(\"Important data\") raise ValueError f.close() <p>Rewrite this code so that the data is written to the file even though it raises an exception.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tryhard/#use-python-idioms","title":"Use Python idioms\u00b6","text":""},{"location":"tryhard/#unpack-values","title":"Unpack values\u00b6","text":""},{"location":"tryhard/#use-comprehensions-judiciously","title":"Use comprehensions judiciously\u00b6","text":""},{"location":"tryhard/#use-more-of-the-standard-library","title":"Use more of the standard library\u00b6","text":""},{"location":"tryhard/#use-more-built-ins","title":"Use more built-ins\u00b6","text":""},{"location":"tryhard/#beg-forgiveness-dont-ask-permission","title":"Beg forgiveness. Don't ask permission\u00b6","text":""},{"location":"tryhard/#use-context-managers","title":"Use context managers\u00b6","text":""},{"location":"tryhard/#exercises","title":"Exercises\u00b6","text":""},{"location":"tryhard/#1-use-unpacking-for-pretty-printing","title":"1) Use unpacking for pretty printing\u00b6","text":"<p>The code below uses a loop to print each value in a collection on a separate line.</p>"},{"location":"tryhard/#2-use-standard-library-data-classes","title":"2) Use standard library data classes\u00b6","text":"<p>The code below uses a dictionary to define a record, then changes one of the values in that record.</p>"},{"location":"tryhard/#3-use-the-built-in-min-and-max-functions","title":"3) Use the built-in min and max functions\u00b6","text":"<p>The code below creates a list of 20 random numbers between -1000 and 1000.</p>"},{"location":"tryhard/#4-just-do-things","title":"4) Just do things\u00b6","text":"<p>The code below defines three records using a named tuple.</p>"},{"location":"tryhard/#5-use-pythonic-patterns-for-setup-and-teardown-boilerplate","title":"5) Use Pythonic patterns for setup and teardown boilerplate\u00b6","text":""}]}